#include <NTPClient.h>
#include "WiFi.h"
#include "esp_camera.h"
#include "esp_timer.h"
#include "img_converters.h"
#include "Arduino.h"
#include "soc/soc.h"           // Disable brownour problems
#include "soc/rtc_cntl_reg.h"  // Disable brownour problems
#include "driver/rtc_io.h"
#include <ESPAsyncWebServer.h>
#include <StringArray.h>
#include <SPIFFS.h>
#include <FS.h>

// Replace with your network credentials
const char* ssid = "NETLIFE-BRUNNO_EXT";
const char* password = "54196721";

// Create AsyncWebServer object on port 80
AsyncWebServer server(80);

boolean takeNewPhoto = false;
String dateTime;
String date;
// Photo File Name to save in SPIFFS
#define FILE_PHOTO "/photo"
String RUTA ;
int contador = 1; 
// OV2640 camera module pins (CAMERA_MODEL_AI_THINKER)
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

const char* ntpServer = "pool.ntp.org"; // Servidor NTP
const long gmtOffset_sec = -18000;     // Offset de tiempo en segundos (para GMT -5, ajusta según tu zona horaria)
const int daylightOffset_sec = 0;   // Offset de horario de verano en segundos

WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, ntpServer, gmtOffset_sec, daylightOffset_sec);


const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML><html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      margin: 0;
      flex: 1;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    
    header {
      background-color: #333;
      color: white;
      padding: 10px 0;
      display: flex;
      align-items: center;
    }
    
    header img {
      width: 150px;
      margin-left: 20px;
    }
    
    .main-content {
      padding: 20px;
    }
    
    .vert { margin-bottom: 10%; }
    .main-content {
      padding: 20px;
      margin-bottom: 80px; /* Agrega un margen inferior para evitar que el footer se solape */
    }
    
    .hori{ margin-bottom: 0%; }
      table {
      width: 50%;
      margin: auto;
      border-collapse: collapse;
      text-align: center;
    }
    
    table, th, td {
      border: 1px solid black;
    }
    
    th {
      font-weight: bold;
    }
  </style>
</head>
<script>
  async function updateTable() {
    var table = document.getElementById("data-table");
    var newRow = table.insertRow(1);
    
    var cell = newRow.insertCell();
    cell.innerHTML = "ID";

    // Fetch de la fecha
    var xhr = new XMLHttpRequest();
    await new Promise(resolve => {
        xhr.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var cellFecha = newRow.insertCell();
                cellFecha.innerHTML = String(this.responseText);
                resolve();
            }
        };
        xhr.open('GET', "/getFecha", true);
        xhr.send();
    });

    // Fetch de la hora
    var xhttp = new XMLHttpRequest();
    await new Promise(resolve => {
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var cellHora = newRow.insertCell();
                cellHora.innerHTML = String(this.responseText);
                resolve();
            }
        };
        xhttp.open('GET', "/getHora", true);
        xhttp.send();
    });

    // Fetch de la foto
    var xhr2 = new XMLHttpRequest();
    await new Promise(resolve => {
        xhr2.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var cellImagen = newRow.insertCell();
                var img = document.createElement("img");
                img.src = String(this.responseText);
                img.id = "photo";
                img.width = 200;
                img.height = 200;
                cellImagen.appendChild(img);
                resolve();
            }
        };
        xhr2.open('GET',"/capture", true);
        xhr2.send();
    });

    if (table.rows.length > 6) {
        table.deleteRow(-1);
    }
}
    

</script>
<body>
<header>
  <img src="data:image/png;base64,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" alt="Logo">
  <h1>SISTEMAS EMBEBIDOS</h1>
</header>
  <div id="container">
    <h2>Proyecto Grupo 3</h2>
    <p>Sistema de seguridad IoT</p>
    <button onclick="updateTable()">Simular boton</button>
  </div>
  <h1>Registro de actividad</h1>
  <table id="data-table" >
    <tr>
      <th>ID</th>
      <th>Fecha</th>
      <th>Hora</th>
      <th>Foto</th>
    </tr>
  </table>
 </body>
  
</html>)rawliteral";



// Check if photo capture was successful
bool checkPhoto( fs::FS &fs ) {
  File f_pic = fs.open( RUTA );
  unsigned int pic_sz = f_pic.size();
  return ( pic_sz > 100 );
}

// Capture Photo and Save it to SPIFFS
void capturePhotoSaveSpiffs( void ) {
  camera_fb_t * fb = NULL; // pointer
  bool ok = 0; // Boolean indicating if the picture has been taken correctly

  do {
    // Take a photo with the camera
    Serial.println("Taking a photo...");
 
    fb = esp_camera_fb_get();
    if (!fb) {
      Serial.println("Camera capture failed");
      return;
    }

    // Photo file name
    Serial.printf("Picture file name: %s\n", RUTA);
    File file = SPIFFS.open(RUTA, FILE_WRITE);

    // Insert the data in the photo file
    if (!file) {
      Serial.println("Failed to open file in writing mode");
    }
    else {
      file.write(fb->buf, fb->len); // payload (image), payload length
      Serial.print("The picture has been saved in ");
      Serial.print(RUTA);
      Serial.print(" - Size: ");
      Serial.print(file.size());
      Serial.println(" bytes");
    }
    // Close the file
    file.close();
    esp_camera_fb_return(fb);

    // check if file has been correctly saved in SPIFFS
    ok = checkPhoto(SPIFFS);
  } while ( !ok );
  if(contador >5){
    contador = 1;
  }else{
    contador = contador +1;
  }
}

void deleteOldPhotos() {
  // Obtén una lista de archivos en el directorio FILE_PHOTO
  File directory = SPIFFS.open("/");
  
  // Borra archivos si hay más de cierto número de fotos almacenadas
  int maxPhotos = 5; // Por ejemplo, solo mantén las últimas 10 fotos
  int deletedCount = 0;

  File file = directory.openNextFile();
  while (file && deletedCount < maxPhotos) {
    String fileName = file.name();
    if (fileName.startsWith(RUTA) && fileName.endsWith(".jpg")) {
      if (SPIFFS.remove(fileName)) {
        Serial.println("Deleted: " + fileName);
      } else {
        Serial.println("Failed to delete: " + fileName);
      }
      deletedCount++;
    }
    file = directory.openNextFile();
  }
}

void listFiles() {
  Serial.println("Listado de archivos:");

  File root = SPIFFS.open("/");
  File file = root.openNextFile();

  while (file) {
    Serial.print("Archivo: ");
    Serial.println(file.name());
    
    // Cierra el archivo antes de eliminarlo
    file.close();
    
    if (SPIFFS.remove(file.name())) {
      Serial.println("Archivo eliminado");
    } else {
      Serial.println("Error al eliminar el archivo");
    }
    
    file = root.openNextFile();
  }

  root.close();
  Serial.println("Fin del listado");
}



void setup() {
  // Serial port for debugging purposes
  Serial.begin(115200);

  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  if (!SPIFFS.begin(true)) {
    Serial.println("An Error has occurred while mounting SPIFFS");
    ESP.restart();
  }
  else {
    delay(500);
    Serial.println("SPIFFS mounted successfully");
  }

  // Print ESP32 Local IP Address
  Serial.print("IP Address: http://");
  Serial.println(WiFi.localIP());

  // Turn-off the 'brownout detector'
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  // OV2640 camera module
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;

  if (psramFound()) {
    config.frame_size = FRAMESIZE_UXGA;
    config.jpeg_quality = 10;
    config.fb_count = 2;
  } else {
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 12;
    config.fb_count = 1;
  }
  // Camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    ESP.restart();
  }

  // Route for root / web page
  server.on("/", HTTP_GET, [](AsyncWebServerRequest * request) {
    request->send_P(200, "text/html", index_html);
  });

  server.on("/capture", HTTP_GET, [](AsyncWebServerRequest * request) {
    RUTA = String(FILE_PHOTO) + "/" + String(contador)+".jpg";
    const char* rutaPtr = RUTA.c_str();  // Convertir el String a const char*
    takeNewPhoto = true;
    request->send_P(200, "text/plain", rutaPtr);  // Enviar el puntero a la cadena
});

  server.on("/getHora", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(200, "text/plain", String(dateTime));
  });

  server.on("/getFecha", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(200, "text/plain", String(date));
  });
  
  server.on(RUTA.c_str(), HTTP_GET, [](AsyncWebServerRequest *request){
  request->send(SPIFFS, RUTA, "image/jpg", false);
   });

  // Start server
  server.begin();
  timeClient.begin();
  listFiles();
  SPIFFS.format();
}

void loop() {
  if (takeNewPhoto) {
    capturePhotoSaveSpiffs();
    deleteOldPhotos();
    takeNewPhoto = false;
  }
  
  delay(1);
  timeClient.update();
  
  dateTime = timeClient.getFormattedTime();

  unsigned long epochTime = timeClient.getEpochTime();
  struct tm *timeinfo;
  timeinfo = localtime((time_t *)&epochTime);

  // Crear una variable de tipo String para almacenar la fecha formateada
  date = String(timeinfo->tm_mday) + "/" + String(timeinfo->tm_mon + 1) + "/" + String(timeinfo->tm_year + 1900);
}
